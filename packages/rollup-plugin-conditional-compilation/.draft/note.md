# rollup-plugin-conditional-compilation 条件编译方法评估笔记

## 1. 当前实现方法（简述）

当前插件主流程是：

1. 用 Acorn 解析源码，并通过 `onComment` 只收集行注释中的指令（`#if/#elif/#else/#endif`）
2. 将指令线性流重建为 `IfBlock` 树（栈结构 + 语法检查）
3. 用表达式求值结果计算每个分支是否保留
4. 以“保留区间”拼接输出代码，并生成 sourcemap

这个设计的优点是：

- 能规避字符串字面量/普通注释中的伪指令
- 嵌套分支逻辑比较清晰
- 接口简单，Rollup `transform` 成本可控

---

## 2. 是否有优化空间：有，且可分三层

## 2.1 低风险、可快速落地

### A. 表达式求值缓存（避免重复 `new Function`）

现状：每次 `#if/#elif` 都会重新构造函数并执行。

可优化：

- 以表达式字符串为 key，缓存编译后的函数
- 相同表达式在同一文件或多文件复用时，减少函数构建开销

收益：中等（大量重复条件时明显）。
风险：低。

### B. directive 识别预筛选

现状：每个行注释都会走 regex 解析。

可优化：

- 先做极轻量前缀判断（例如首字符不是 `#` 直接跳过）
- 再走完整 regex

收益：小到中等（注释很多时有价值）。
风险：低。

### C. `toIfBlocks` 与 `compile` 的中间对象减量

现状：先构建完整 `IfBlock` 树，再二次遍历生成保留区间。

可优化：

- 若目标是性能优先，可改为“单次栈遍历直接记录删除/保留边界”
- 在不改 API 的前提下可先局部减少对象字段与临时数组

收益：中等（大文件场景）。
风险：低到中等（需保证错误定位信息不退化）。

---

## 2.2 中风险、收益较高

### D. sourcemap 构建复杂度优化（当前热点）

现状：`getLineColumn(code, offset)` 每次都从头扫描，且在字符级循环中频繁调用，整体趋向 **O(n^2)**。

可优化（两种路径）：

1. 维护增量行列状态，遍历 chunk 时同步推进，不重复从头计算
2. 预构建换行索引表，再用二分定位 line/column（近似 O(n log n)）

收益：高（长文件/大量保留片段时差异明显）。
风险：中（需要补足 sourcemap 正确性测试）。

> 若允许引入依赖，直接采用 `magic-string` 处理切片和 sourcemap，通常可显著降低维护成本与错误率。

---

## 2.3 高风险/策略级优化

### E. 替换表达式执行策略

现状：表达式由 `new Function` 执行，能力强但安全边界宽。

可优化：

- 改为受限表达式求值器（只允许布尔/比较/逻辑/算术等 AST 子集）
- 或使用安全表达式库

收益：安全性显著提升。
风险：高（语法兼容范围会收缩，需要定义“支持的表达式语法子集”）。

---

## 3. C++ 编译器的 if 处理方式是否能用在这里？

先结论：**能借鉴“条件状态机和短路分支选择”，不能直接照搬 C/C++ 预处理器模型。**

## 3.1 为什么不能直接照搬

C/C++ 的 `#if` 在预处理阶段工作，核心前提是：

- 条件表达式通常是“宏 + 常量表达式”
- 预处理器在词法层面处理 token
- 被裁剪分支可不进入后续语义分析

而本插件当前语义是：

- 指令写在 JS 行注释里
- 条件表达式按 JavaScript 语法执行
- 需要与 JS/TS 工具链（Acorn/Rollup/sourcemap）协同

因此不能直接移植 C++ 预处理器的实现。

## 3.2 可以迁移的“思想”

### 可迁移 1：三态活动标记（active / inactive / done）

对 `if-elif-else` 链维护父状态与“是否已命中”状态，可更早短路后续 `elif`，减少求值次数。

### 可迁移 2：单遍扫描 + 栈机

像预处理器一样，单次线性扫描中完成：

- 语法合法性检查
- 分支状态转移
- 删除区间收集

这与当前两阶段（建树+编译）相比，可降低中间结构成本。

### 可迁移 3：跳过非活动分支的进一步处理

当父层已确定不可达时，子层无需再做表达式求值，只做结构平衡检查即可。

---

## 4. 建议的落地优先级

### P0（建议立即）

1. sourcemap 行列计算改为增量法或换行索引法
2. 表达式函数缓存（按 expr key）
3. 增补性能基准（大文件 + 深嵌套 + 多 elif）

### P1（建议随后）

1. 引入“父分支不可达时跳过求值”的短路机制
2. 评估“单遍栈机”替代当前建树流程（先做 PoC）

### P2（按安全需求决定）

1. 设计受限表达式语法并替换 `new Function`
2. 明确向后兼容策略（是否允许破坏性收敛）

---

## 5. 额外观察（与本次评估相关）

- 测试文件中存在“把 `CompileResult` 当 string 使用”的写法迹象，可能是测试与实现的返回类型发生过漂移。
- 若后续做性能/结构改造，建议先统一测试断言接口（例如统一 `result.code` 断言），否则评估噪音会偏大。

---

## 6. 总结

- 当前实现可用且结构清晰，但在 **sourcemap 性能** 和 **表达式执行策略** 上仍有明显优化空间。
- C++ `if` 机制可迁移的是“状态机与短路思想”，不是其预处理器本体。
- 若目标是“尽快提速且不破坏行为”，优先做 P0；若目标是“安全与长期维护”，再推进 P2。
